{"ast":null,"code":"// Load modules.\nvar passport = require('passport-strategy'),\n    url = require('url'),\n    uid = require('uid2'),\n    crypto = require('crypto'),\n    base64url = require('base64url'),\n    util = require('util'),\n    utils = require('./utils'),\n    OAuth2 = require('oauth').OAuth2,\n    NullStateStore = require('./state/null'),\n    SessionStateStore = require('./state/session'),\n    PKCESessionStateStore = require('./state/pkcesession'),\n    AuthorizationError = require('./errors/authorizationerror'),\n    TokenError = require('./errors/tokenerror'),\n    InternalOAuthError = require('./errors/internaloautherror');\n/**\n * Creates an instance of `OAuth2Strategy`.\n *\n * The OAuth 2.0 authentication strategy authenticates requests using the OAuth\n * 2.0 framework.\n *\n * OAuth 2.0 provides a facility for delegated authentication, whereby users can\n * authenticate using a third-party service such as Facebook.  Delegating in\n * this manner involves a sequence of events, including redirecting the user to\n * the third-party service for authorization.  Once authorization has been\n * granted, the user is redirected back to the application and an authorization\n * code can be used to obtain credentials.\n *\n * Applications must supply a `verify` callback, for which the function\n * signature is:\n *\n *     function(accessToken, refreshToken, profile, done) { ... }\n *\n * The verify callback is responsible for finding or creating the user, and\n * invoking `done` with the following arguments:\n *\n *     done(err, user, info);\n *\n * `user` should be set to `false` to indicate an authentication failure.\n * Additional `info` can optionally be passed as a third argument, typically\n * used to display informational messages.  If an exception occured, `err`\n * should be set.\n *\n * Options:\n *\n *   - `authorizationURL`  URL used to obtain an authorization grant\n *   - `tokenURL`          URL used to obtain an access token\n *   - `clientID`          identifies client to service provider\n *   - `clientSecret`      secret used to establish ownership of the client identifer\n *   - `callbackURL`       URL to which the service provider will redirect the user after obtaining authorization\n *   - `passReqToCallback` when `true`, `req` is the first argument to the verify callback (default: `false`)\n *\n * Examples:\n *\n *     passport.use(new OAuth2Strategy({\n *         authorizationURL: 'https://www.example.com/oauth2/authorize',\n *         tokenURL: 'https://www.example.com/oauth2/token',\n *         clientID: '123-456-789',\n *         clientSecret: 'shhh-its-a-secret'\n *         callbackURL: 'https://www.example.net/auth/example/callback'\n *       },\n *       function(accessToken, refreshToken, profile, done) {\n *         User.findOrCreate(..., function (err, user) {\n *           done(err, user);\n *         });\n *       }\n *     ));\n *\n * @constructor\n * @param {Object} options\n * @param {Function} verify\n * @api public\n */\n\n\nfunction OAuth2Strategy(options, verify) {\n  if (typeof options == 'function') {\n    verify = options;\n    options = undefined;\n  }\n\n  options = options || {};\n\n  if (!verify) {\n    throw new TypeError('OAuth2Strategy requires a verify callback');\n  }\n\n  if (!options.authorizationURL) {\n    throw new TypeError('OAuth2Strategy requires a authorizationURL option');\n  }\n\n  if (!options.tokenURL) {\n    throw new TypeError('OAuth2Strategy requires a tokenURL option');\n  }\n\n  if (!options.clientID) {\n    throw new TypeError('OAuth2Strategy requires a clientID option');\n  }\n\n  passport.Strategy.call(this);\n  this.name = 'oauth2';\n  this._verify = verify; // NOTE: The _oauth2 property is considered \"protected\".  Subclasses are\n  //       allowed to use it when making protected resource requests to retrieve\n  //       the user profile.\n\n  this._oauth2 = new OAuth2(options.clientID, options.clientSecret, '', options.authorizationURL, options.tokenURL, options.customHeaders);\n  this._callbackURL = options.callbackURL;\n  this._scope = options.scope;\n  this._scopeSeparator = options.scopeSeparator || ' ';\n  this._pkceMethod = options.pkce === true ? 'S256' : options.pkce;\n  this._key = options.sessionKey || 'oauth2:' + url.parse(options.authorizationURL).hostname;\n\n  if (options.store) {\n    this._stateStore = options.store;\n  } else {\n    if (options.state) {\n      this._stateStore = options.pkce ? new PKCESessionStateStore({\n        key: this._key\n      }) : new SessionStateStore({\n        key: this._key\n      });\n    } else {\n      if (options.pkce) {\n        throw new TypeError('OAuth2Strategy requires `state: true` option when PKCE is enabled');\n      }\n\n      this._stateStore = new NullStateStore();\n    }\n  }\n\n  this._trustProxy = options.proxy;\n  this._passReqToCallback = options.passReqToCallback;\n  this._skipUserProfile = options.skipUserProfile === undefined ? false : options.skipUserProfile;\n} // Inherit from `passport.Strategy`.\n\n\nutil.inherits(OAuth2Strategy, passport.Strategy);\n/**\n * Authenticate request by delegating to a service provider using OAuth 2.0.\n *\n * @param {Object} req\n * @api protected\n */\n\nOAuth2Strategy.prototype.authenticate = function (req, options) {\n  options = options || {};\n  var self = this;\n\n  if (req.query && req.query.error) {\n    if (req.query.error == 'access_denied') {\n      return this.fail({\n        message: req.query.error_description\n      });\n    } else {\n      return this.error(new AuthorizationError(req.query.error_description, req.query.error, req.query.error_uri));\n    }\n  }\n\n  var callbackURL = options.callbackURL || this._callbackURL;\n\n  if (callbackURL) {\n    var parsed = url.parse(callbackURL);\n\n    if (!parsed.protocol) {\n      // The callback URL is relative, resolve a fully qualified URL from the\n      // URL of the originating request.\n      callbackURL = url.resolve(utils.originalURL(req, {\n        proxy: this._trustProxy\n      }), callbackURL);\n    }\n  }\n\n  var meta = {\n    authorizationURL: this._oauth2._authorizeUrl,\n    tokenURL: this._oauth2._accessTokenUrl,\n    clientID: this._oauth2._clientId\n  };\n\n  if (req.query && req.query.code) {\n    function loaded(err, ok, state) {\n      if (err) {\n        return self.error(err);\n      }\n\n      if (!ok) {\n        return self.fail(state, 403);\n      }\n\n      var code = req.query.code;\n      var params = self.tokenParams(options);\n      params.grant_type = 'authorization_code';\n\n      if (callbackURL) {\n        params.redirect_uri = callbackURL;\n      }\n\n      if (typeof ok == 'string') {\n        // PKCE\n        params.code_verifier = ok;\n      }\n\n      self._oauth2.getOAuthAccessToken(code, params, function (err, accessToken, refreshToken, params) {\n        if (err) {\n          return self.error(self._createOAuthError('Failed to obtain access token', err));\n        }\n\n        self._loadUserProfile(accessToken, function (err, profile) {\n          if (err) {\n            return self.error(err);\n          }\n\n          function verified(err, user, info) {\n            if (err) {\n              return self.error(err);\n            }\n\n            if (!user) {\n              return self.fail(info);\n            }\n\n            info = info || {};\n\n            if (state) {\n              info.state = state;\n            }\n\n            self.success(user, info);\n          }\n\n          try {\n            if (self._passReqToCallback) {\n              var arity = self._verify.length;\n\n              if (arity == 6) {\n                self._verify(req, accessToken, refreshToken, params, profile, verified);\n              } else {\n                // arity == 5\n                self._verify(req, accessToken, refreshToken, profile, verified);\n              }\n            } else {\n              var arity = self._verify.length;\n\n              if (arity == 5) {\n                self._verify(accessToken, refreshToken, params, profile, verified);\n              } else {\n                // arity == 4\n                self._verify(accessToken, refreshToken, profile, verified);\n              }\n            }\n          } catch (ex) {\n            return self.error(ex);\n          }\n        });\n      });\n    }\n\n    var state = req.query.state;\n\n    try {\n      var arity = this._stateStore.verify.length;\n\n      if (arity == 4) {\n        this._stateStore.verify(req, state, meta, loaded);\n      } else {\n        // arity == 3\n        this._stateStore.verify(req, state, loaded);\n      }\n    } catch (ex) {\n      return this.error(ex);\n    }\n  } else {\n    var params = this.authorizationParams(options);\n    params.response_type = 'code';\n\n    if (callbackURL) {\n      params.redirect_uri = callbackURL;\n    }\n\n    var scope = options.scope || this._scope;\n\n    if (scope) {\n      if (Array.isArray(scope)) {\n        scope = scope.join(this._scopeSeparator);\n      }\n\n      params.scope = scope;\n    }\n\n    var verifier, challenge;\n\n    if (this._pkceMethod) {\n      verifier = base64url(crypto.pseudoRandomBytes(32));\n\n      switch (this._pkceMethod) {\n        case 'plain':\n          challenge = verifier;\n          break;\n\n        case 'S256':\n          challenge = base64url(crypto.createHash('sha256').update(verifier).digest());\n          break;\n\n        default:\n          return this.error(new Error('Unsupported code verifier transformation method: ' + this._pkceMethod));\n      }\n\n      params.code_challenge = challenge;\n      params.code_challenge_method = this._pkceMethod;\n    }\n\n    var state = options.state;\n\n    if (state) {\n      params.state = state;\n      var parsed = url.parse(this._oauth2._authorizeUrl, true);\n      utils.merge(parsed.query, params);\n      parsed.query['client_id'] = this._oauth2._clientId;\n      delete parsed.search;\n      var location = url.format(parsed);\n      this.redirect(location);\n    } else {\n      function stored(err, state) {\n        if (err) {\n          return self.error(err);\n        }\n\n        if (state) {\n          params.state = state;\n        }\n\n        var parsed = url.parse(self._oauth2._authorizeUrl, true);\n        utils.merge(parsed.query, params);\n        parsed.query['client_id'] = self._oauth2._clientId;\n        delete parsed.search;\n        var location = url.format(parsed);\n        self.redirect(location);\n      }\n\n      try {\n        var arity = this._stateStore.store.length;\n\n        if (arity == 5) {\n          this._stateStore.store(req, verifier, undefined, meta, stored);\n        } else if (arity == 3) {\n          this._stateStore.store(req, meta, stored);\n        } else {\n          // arity == 2\n          this._stateStore.store(req, stored);\n        }\n      } catch (ex) {\n        return this.error(ex);\n      }\n    }\n  }\n};\n/**\n * Retrieve user profile from service provider.\n *\n * OAuth 2.0-based authentication strategies can overrride this function in\n * order to load the user's profile from the service provider.  This assists\n * applications (and users of those applications) in the initial registration\n * process by automatically submitting required information.\n *\n * @param {String} accessToken\n * @param {Function} done\n * @api protected\n */\n\n\nOAuth2Strategy.prototype.userProfile = function (accessToken, done) {\n  return done(null, {});\n};\n/**\n * Return extra parameters to be included in the authorization request.\n *\n * Some OAuth 2.0 providers allow additional, non-standard parameters to be\n * included when requesting authorization.  Since these parameters are not\n * standardized by the OAuth 2.0 specification, OAuth 2.0-based authentication\n * strategies can overrride this function in order to populate these parameters\n * as required by the provider.\n *\n * @param {Object} options\n * @return {Object}\n * @api protected\n */\n\n\nOAuth2Strategy.prototype.authorizationParams = function (options) {\n  return {};\n};\n/**\n * Return extra parameters to be included in the token request.\n *\n * Some OAuth 2.0 providers allow additional, non-standard parameters to be\n * included when requesting an access token.  Since these parameters are not\n * standardized by the OAuth 2.0 specification, OAuth 2.0-based authentication\n * strategies can overrride this function in order to populate these parameters\n * as required by the provider.\n *\n * @return {Object}\n * @api protected\n */\n\n\nOAuth2Strategy.prototype.tokenParams = function (options) {\n  return {};\n};\n/**\n * Parse error response from OAuth 2.0 endpoint.\n *\n * OAuth 2.0-based authentication strategies can overrride this function in\n * order to parse error responses received from the token endpoint, allowing the\n * most informative message to be displayed.\n *\n * If this function is not overridden, the body will be parsed in accordance\n * with RFC 6749, section 5.2.\n *\n * @param {String} body\n * @param {Number} status\n * @return {Error}\n * @api protected\n */\n\n\nOAuth2Strategy.prototype.parseErrorResponse = function (body, status) {\n  var json = JSON.parse(body);\n\n  if (json.error) {\n    return new TokenError(json.error_description, json.error, json.error_uri);\n  }\n\n  return null;\n};\n/**\n * Load user profile, contingent upon options.\n *\n * @param {String} accessToken\n * @param {Function} done\n * @api private\n */\n\n\nOAuth2Strategy.prototype._loadUserProfile = function (accessToken, done) {\n  var self = this;\n\n  function loadIt() {\n    return self.userProfile(accessToken, done);\n  }\n\n  function skipIt() {\n    return done(null);\n  }\n\n  if (typeof this._skipUserProfile == 'function' && this._skipUserProfile.length > 1) {\n    // async\n    this._skipUserProfile(accessToken, function (err, skip) {\n      if (err) {\n        return done(err);\n      }\n\n      if (!skip) {\n        return loadIt();\n      }\n\n      return skipIt();\n    });\n  } else {\n    var skip = typeof this._skipUserProfile == 'function' ? this._skipUserProfile() : this._skipUserProfile;\n\n    if (!skip) {\n      return loadIt();\n    }\n\n    return skipIt();\n  }\n};\n/**\n * Create an OAuth error.\n *\n * @param {String} message\n * @param {Object|Error} err\n * @api private\n */\n\n\nOAuth2Strategy.prototype._createOAuthError = function (message, err) {\n  var e;\n\n  if (err.statusCode && err.data) {\n    try {\n      e = this.parseErrorResponse(err.data, err.statusCode);\n    } catch (_) {}\n  }\n\n  if (!e) {\n    e = new InternalOAuthError(message, err);\n  }\n\n  return e;\n}; // Expose constructor.\n\n\nmodule.exports = OAuth2Strategy;","map":{"version":3,"sources":["/home/astitva/Desktop/basic-react/node_modules/passport-oauth2/lib/strategy.js"],"names":["passport","require","url","uid","crypto","base64url","util","utils","OAuth2","NullStateStore","SessionStateStore","PKCESessionStateStore","AuthorizationError","TokenError","InternalOAuthError","OAuth2Strategy","options","verify","undefined","TypeError","authorizationURL","tokenURL","clientID","Strategy","call","name","_verify","_oauth2","clientSecret","customHeaders","_callbackURL","callbackURL","_scope","scope","_scopeSeparator","scopeSeparator","_pkceMethod","pkce","_key","sessionKey","parse","hostname","store","_stateStore","state","key","_trustProxy","proxy","_passReqToCallback","passReqToCallback","_skipUserProfile","skipUserProfile","inherits","prototype","authenticate","req","self","query","error","fail","message","error_description","error_uri","parsed","protocol","resolve","originalURL","meta","_authorizeUrl","_accessTokenUrl","_clientId","code","loaded","err","ok","params","tokenParams","grant_type","redirect_uri","code_verifier","getOAuthAccessToken","accessToken","refreshToken","_createOAuthError","_loadUserProfile","profile","verified","user","info","success","arity","length","ex","authorizationParams","response_type","Array","isArray","join","verifier","challenge","pseudoRandomBytes","createHash","update","digest","Error","code_challenge","code_challenge_method","merge","search","location","format","redirect","stored","userProfile","done","parseErrorResponse","body","status","json","JSON","loadIt","skipIt","skip","e","statusCode","data","_","module","exports"],"mappings":"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","sourcesContent":["// Load modules.\nvar passport = require('passport-strategy')\n  , url = require('url')\n  , uid = require('uid2')\n  , crypto = require('crypto')\n  , base64url = require('base64url')\n  , util = require('util')\n  , utils = require('./utils')\n  , OAuth2 = require('oauth').OAuth2\n  , NullStateStore = require('./state/null')\n  , SessionStateStore = require('./state/session')\n  , PKCESessionStateStore = require('./state/pkcesession')\n  , AuthorizationError = require('./errors/authorizationerror')\n  , TokenError = require('./errors/tokenerror')\n  , InternalOAuthError = require('./errors/internaloautherror');\n\n\n/**\n * Creates an instance of `OAuth2Strategy`.\n *\n * The OAuth 2.0 authentication strategy authenticates requests using the OAuth\n * 2.0 framework.\n *\n * OAuth 2.0 provides a facility for delegated authentication, whereby users can\n * authenticate using a third-party service such as Facebook.  Delegating in\n * this manner involves a sequence of events, including redirecting the user to\n * the third-party service for authorization.  Once authorization has been\n * granted, the user is redirected back to the application and an authorization\n * code can be used to obtain credentials.\n *\n * Applications must supply a `verify` callback, for which the function\n * signature is:\n *\n *     function(accessToken, refreshToken, profile, done) { ... }\n *\n * The verify callback is responsible for finding or creating the user, and\n * invoking `done` with the following arguments:\n *\n *     done(err, user, info);\n *\n * `user` should be set to `false` to indicate an authentication failure.\n * Additional `info` can optionally be passed as a third argument, typically\n * used to display informational messages.  If an exception occured, `err`\n * should be set.\n *\n * Options:\n *\n *   - `authorizationURL`  URL used to obtain an authorization grant\n *   - `tokenURL`          URL used to obtain an access token\n *   - `clientID`          identifies client to service provider\n *   - `clientSecret`      secret used to establish ownership of the client identifer\n *   - `callbackURL`       URL to which the service provider will redirect the user after obtaining authorization\n *   - `passReqToCallback` when `true`, `req` is the first argument to the verify callback (default: `false`)\n *\n * Examples:\n *\n *     passport.use(new OAuth2Strategy({\n *         authorizationURL: 'https://www.example.com/oauth2/authorize',\n *         tokenURL: 'https://www.example.com/oauth2/token',\n *         clientID: '123-456-789',\n *         clientSecret: 'shhh-its-a-secret'\n *         callbackURL: 'https://www.example.net/auth/example/callback'\n *       },\n *       function(accessToken, refreshToken, profile, done) {\n *         User.findOrCreate(..., function (err, user) {\n *           done(err, user);\n *         });\n *       }\n *     ));\n *\n * @constructor\n * @param {Object} options\n * @param {Function} verify\n * @api public\n */\nfunction OAuth2Strategy(options, verify) {\n  if (typeof options == 'function') {\n    verify = options;\n    options = undefined;\n  }\n  options = options || {};\n\n  if (!verify) { throw new TypeError('OAuth2Strategy requires a verify callback'); }\n  if (!options.authorizationURL) { throw new TypeError('OAuth2Strategy requires a authorizationURL option'); }\n  if (!options.tokenURL) { throw new TypeError('OAuth2Strategy requires a tokenURL option'); }\n  if (!options.clientID) { throw new TypeError('OAuth2Strategy requires a clientID option'); }\n\n  passport.Strategy.call(this);\n  this.name = 'oauth2';\n  this._verify = verify;\n\n  // NOTE: The _oauth2 property is considered \"protected\".  Subclasses are\n  //       allowed to use it when making protected resource requests to retrieve\n  //       the user profile.\n  this._oauth2 = new OAuth2(options.clientID,  options.clientSecret,\n                            '', options.authorizationURL, options.tokenURL, options.customHeaders);\n\n  this._callbackURL = options.callbackURL;\n  this._scope = options.scope;\n  this._scopeSeparator = options.scopeSeparator || ' ';\n  this._pkceMethod = (options.pkce === true) ? 'S256' : options.pkce;\n  this._key = options.sessionKey || ('oauth2:' + url.parse(options.authorizationURL).hostname);\n\n  if (options.store) {\n    this._stateStore = options.store;\n  } else {\n    if (options.state) {\n      this._stateStore = options.pkce ? new PKCESessionStateStore({ key: this._key }) : new SessionStateStore({ key: this._key });\n    } else {\n      if (options.pkce) { throw new TypeError('OAuth2Strategy requires `state: true` option when PKCE is enabled'); }\n      this._stateStore = new NullStateStore();\n    }\n  }\n  this._trustProxy = options.proxy;\n  this._passReqToCallback = options.passReqToCallback;\n  this._skipUserProfile = (options.skipUserProfile === undefined) ? false : options.skipUserProfile;\n}\n\n// Inherit from `passport.Strategy`.\nutil.inherits(OAuth2Strategy, passport.Strategy);\n\n\n/**\n * Authenticate request by delegating to a service provider using OAuth 2.0.\n *\n * @param {Object} req\n * @api protected\n */\nOAuth2Strategy.prototype.authenticate = function(req, options) {\n  options = options || {};\n  var self = this;\n\n  if (req.query && req.query.error) {\n    if (req.query.error == 'access_denied') {\n      return this.fail({ message: req.query.error_description });\n    } else {\n      return this.error(new AuthorizationError(req.query.error_description, req.query.error, req.query.error_uri));\n    }\n  }\n\n  var callbackURL = options.callbackURL || this._callbackURL;\n  if (callbackURL) {\n    var parsed = url.parse(callbackURL);\n    if (!parsed.protocol) {\n      // The callback URL is relative, resolve a fully qualified URL from the\n      // URL of the originating request.\n      callbackURL = url.resolve(utils.originalURL(req, { proxy: this._trustProxy }), callbackURL);\n    }\n  }\n\n  var meta = {\n    authorizationURL: this._oauth2._authorizeUrl,\n    tokenURL: this._oauth2._accessTokenUrl,\n    clientID: this._oauth2._clientId\n  }\n\n  if (req.query && req.query.code) {\n    function loaded(err, ok, state) {\n      if (err) { return self.error(err); }\n      if (!ok) {\n        return self.fail(state, 403);\n      }\n\n      var code = req.query.code;\n\n      var params = self.tokenParams(options);\n      params.grant_type = 'authorization_code';\n      if (callbackURL) { params.redirect_uri = callbackURL; }\n      if (typeof ok == 'string') { // PKCE\n        params.code_verifier = ok;\n      }\n\n      self._oauth2.getOAuthAccessToken(code, params,\n        function(err, accessToken, refreshToken, params) {\n          if (err) { return self.error(self._createOAuthError('Failed to obtain access token', err)); }\n\n          self._loadUserProfile(accessToken, function(err, profile) {\n            if (err) { return self.error(err); }\n\n            function verified(err, user, info) {\n              if (err) { return self.error(err); }\n              if (!user) { return self.fail(info); }\n\n              info = info || {};\n              if (state) { info.state = state; }\n              self.success(user, info);\n            }\n\n            try {\n              if (self._passReqToCallback) {\n                var arity = self._verify.length;\n                if (arity == 6) {\n                  self._verify(req, accessToken, refreshToken, params, profile, verified);\n                } else { // arity == 5\n                  self._verify(req, accessToken, refreshToken, profile, verified);\n                }\n              } else {\n                var arity = self._verify.length;\n                if (arity == 5) {\n                  self._verify(accessToken, refreshToken, params, profile, verified);\n                } else { // arity == 4\n                  self._verify(accessToken, refreshToken, profile, verified);\n                }\n              }\n            } catch (ex) {\n              return self.error(ex);\n            }\n          });\n        }\n      );\n    }\n\n    var state = req.query.state;\n    try {\n      var arity = this._stateStore.verify.length;\n      if (arity == 4) {\n        this._stateStore.verify(req, state, meta, loaded);\n      } else { // arity == 3\n        this._stateStore.verify(req, state, loaded);\n      }\n    } catch (ex) {\n      return this.error(ex);\n    }\n  } else {\n    var params = this.authorizationParams(options);\n    params.response_type = 'code';\n    if (callbackURL) { params.redirect_uri = callbackURL; }\n    var scope = options.scope || this._scope;\n    if (scope) {\n      if (Array.isArray(scope)) { scope = scope.join(this._scopeSeparator); }\n      params.scope = scope;\n    }\n    var verifier, challenge;\n\n    if (this._pkceMethod) {\n      verifier = base64url(crypto.pseudoRandomBytes(32))\n      switch (this._pkceMethod) {\n      case 'plain':\n        challenge = verifier;\n        break;\n      case 'S256':\n        challenge = base64url(crypto.createHash('sha256').update(verifier).digest());\n        break;\n      default:\n        return this.error(new Error('Unsupported code verifier transformation method: ' + this._pkceMethod));\n      }\n      \n      params.code_challenge = challenge;\n      params.code_challenge_method = this._pkceMethod;\n    }\n\n    var state = options.state;\n    if (state) {\n      params.state = state;\n      \n      var parsed = url.parse(this._oauth2._authorizeUrl, true);\n      utils.merge(parsed.query, params);\n      parsed.query['client_id'] = this._oauth2._clientId;\n      delete parsed.search;\n      var location = url.format(parsed);\n      this.redirect(location);\n    } else {\n      function stored(err, state) {\n        if (err) { return self.error(err); }\n\n        if (state) { params.state = state; }\n        var parsed = url.parse(self._oauth2._authorizeUrl, true);\n        utils.merge(parsed.query, params);\n        parsed.query['client_id'] = self._oauth2._clientId;\n        delete parsed.search;\n        var location = url.format(parsed);\n        self.redirect(location);\n      }\n\n      try {\n        var arity = this._stateStore.store.length;\n        if (arity == 5) {\n          this._stateStore.store(req, verifier, undefined, meta, stored);\n        } else if (arity == 3) {\n          this._stateStore.store(req, meta, stored);\n        } else { // arity == 2\n          this._stateStore.store(req, stored);\n        }\n      } catch (ex) {\n        return this.error(ex);\n      }\n    }\n  }\n};\n\n/**\n * Retrieve user profile from service provider.\n *\n * OAuth 2.0-based authentication strategies can overrride this function in\n * order to load the user's profile from the service provider.  This assists\n * applications (and users of those applications) in the initial registration\n * process by automatically submitting required information.\n *\n * @param {String} accessToken\n * @param {Function} done\n * @api protected\n */\nOAuth2Strategy.prototype.userProfile = function(accessToken, done) {\n  return done(null, {});\n};\n\n/**\n * Return extra parameters to be included in the authorization request.\n *\n * Some OAuth 2.0 providers allow additional, non-standard parameters to be\n * included when requesting authorization.  Since these parameters are not\n * standardized by the OAuth 2.0 specification, OAuth 2.0-based authentication\n * strategies can overrride this function in order to populate these parameters\n * as required by the provider.\n *\n * @param {Object} options\n * @return {Object}\n * @api protected\n */\nOAuth2Strategy.prototype.authorizationParams = function(options) {\n  return {};\n};\n\n/**\n * Return extra parameters to be included in the token request.\n *\n * Some OAuth 2.0 providers allow additional, non-standard parameters to be\n * included when requesting an access token.  Since these parameters are not\n * standardized by the OAuth 2.0 specification, OAuth 2.0-based authentication\n * strategies can overrride this function in order to populate these parameters\n * as required by the provider.\n *\n * @return {Object}\n * @api protected\n */\nOAuth2Strategy.prototype.tokenParams = function(options) {\n  return {};\n};\n\n/**\n * Parse error response from OAuth 2.0 endpoint.\n *\n * OAuth 2.0-based authentication strategies can overrride this function in\n * order to parse error responses received from the token endpoint, allowing the\n * most informative message to be displayed.\n *\n * If this function is not overridden, the body will be parsed in accordance\n * with RFC 6749, section 5.2.\n *\n * @param {String} body\n * @param {Number} status\n * @return {Error}\n * @api protected\n */\nOAuth2Strategy.prototype.parseErrorResponse = function(body, status) {\n  var json = JSON.parse(body);\n  if (json.error) {\n    return new TokenError(json.error_description, json.error, json.error_uri);\n  }\n  return null;\n};\n\n/**\n * Load user profile, contingent upon options.\n *\n * @param {String} accessToken\n * @param {Function} done\n * @api private\n */\nOAuth2Strategy.prototype._loadUserProfile = function(accessToken, done) {\n  var self = this;\n\n  function loadIt() {\n    return self.userProfile(accessToken, done);\n  }\n  function skipIt() {\n    return done(null);\n  }\n\n  if (typeof this._skipUserProfile == 'function' && this._skipUserProfile.length > 1) {\n    // async\n    this._skipUserProfile(accessToken, function(err, skip) {\n      if (err) { return done(err); }\n      if (!skip) { return loadIt(); }\n      return skipIt();\n    });\n  } else {\n    var skip = (typeof this._skipUserProfile == 'function') ? this._skipUserProfile() : this._skipUserProfile;\n    if (!skip) { return loadIt(); }\n    return skipIt();\n  }\n};\n\n/**\n * Create an OAuth error.\n *\n * @param {String} message\n * @param {Object|Error} err\n * @api private\n */\nOAuth2Strategy.prototype._createOAuthError = function(message, err) {\n  var e;\n  if (err.statusCode && err.data) {\n    try {\n      e = this.parseErrorResponse(err.data, err.statusCode);\n    } catch (_) {}\n  }\n  if (!e) { e = new InternalOAuthError(message, err); }\n  return e;\n};\n\n\n// Expose constructor.\nmodule.exports = OAuth2Strategy;\n"]},"metadata":{},"sourceType":"script"}